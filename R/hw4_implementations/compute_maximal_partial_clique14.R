#' Compute maximal partial clique function
#'
#'This function identifies a subset of nodes in a binary symmetric adjacency matrix
#' that form a maximal partial clique with edge density at least `alpha`.
#' It uses a greedy expansion algorithm starting from the top-k highest-degree nodes
#' and iteratively adds nodes while maintaining the required edge density. However,
#' is not guarantee the best solution in every task, limited by top-k, especially when
#' top-k is large or matrix size is large.
#'
#' @importFrom utils combn
#'
#' @param adj_mat A nxn undirected graph with 1 meaning connected and 0 meaning unconnected. It is symmetric and should be generated by some generate_partial_clique_function. n is from 5 to 50 inclusive.
#' @param alpha The threshold of minimum edge density of the potential clique. It should range from 0.5 to 1 inclusive.
#' @param top_k_seeds A value that make algorithm more efficient by setting starter nodes with most connections. It is set to sqrt of number of nodes in matrix.
#'
#' @return A list with two elements:
#' \describe{
#'    \item{clique_idx}{a numeric vector of node indices in the partial clique.}
#'    \item{edge_density}{the edge density among those nodes.}
#'  }
#' @export
compute_maximal_partial_clique14 <-
  function(adj_mat, alpha, top_k_seeds = NULL) {
    # --- Input checks ---
    if (!is.matrix(adj_mat) ||
        !is.numeric(adj_mat))
      stop("adj_mat must be a numeric matrix.")
    if (nrow(adj_mat) != ncol(adj_mat))
      stop("adj_mat must be square.")
    if (!all(adj_mat %in% c(0, 1)))
      stop("adj_mat must contain only 0s and 1s.")
    if (!all(diag(adj_mat) == 1))
      stop("Diagonal entries must be 1.")
    if (!isSymmetric(adj_mat))
      stop("adj_mat must be symmetric.")
    if (!is.null(dimnames(adj_mat)))
      stop("adj_mat should not have row or column names.")
    if (!(nrow(adj_mat) >= 5 &&
          nrow(adj_mat) <= 50))
      stop("adj_mat must be between 5 and 50 nodes.")
    
    if (!is.numeric(alpha) ||
        length(alpha) != 1)
      stop("alpha must be a single numeric.")
    if (!(alpha >= 0.5 &&
          alpha <= 1))
      stop("alpha must be between 0.5 and 1.")
    
    n <- nrow(adj_mat)
    if (is.null(top_k_seeds)) {
      top_k_seeds <- ceiling(sqrt(n))
    }
    
    # --- Helper: edge density ---
    edge_density <- function(nodes) {
      if (length(nodes) <= 1)
        return(1)
      submat <- adj_mat[nodes, nodes]
      edges <- sum(submat) - length(nodes)
      possible <- length(nodes) * (length(nodes) - 1)
      return(edges / possible)
    }
    
    n <- nrow(adj_mat)
    degrees <- rowSums(adj_mat)
    seed_nodes <-
      order(degrees, decreasing = TRUE)[1:min(top_k_seeds, n)]
    
    best_group <- NULL
    best_density <- 0
    
    for (seed in seed_nodes) {
      group <- c(seed)
      candidates <- setdiff(1:n, seed)
      
      repeat {
        added <- FALSE
        for (v in candidates) {
          new_group <- c(group, v)
          d <- edge_density(new_group)
          if (d >= alpha) {
            group <- new_group
            candidates <- setdiff(candidates, v)
            added <- TRUE
            break
          }
        }
        if (!added)
          break
      }
      
      final_density <- edge_density(group)
      if (length(group) > length(best_group)) {
        best_group <- group
        best_density <- final_density
      }
    }
    
    return(list(
      clique_idx = sort(best_group),
      edge_density = best_density
    ))
  }